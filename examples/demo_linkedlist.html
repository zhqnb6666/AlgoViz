<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>算法可视化 - 多数据结构</title>
    <!-- 引入Vue.js -->
    <script src="https://cdn.jsdelivr.net/npm/vue@3.2.47/dist/vue.global.js"></script>
    <!-- 引入D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- 引入Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        [v-cloak] { 
            display: none; 
        }
        .fade-enter-active, .fade-leave-active {
            transition: opacity 0.5s;
        }
        .fade-enter-from, .fade-leave-to {
            opacity: 0;
        }
        /* 可视化区域样式 */
        .visualization-container {
            min-height: 300px;
            max-height: 600px;
            overflow: auto;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        /* 链表和树的样式 */
        .node circle {
            fill: white;
            stroke: #999;
            stroke-width: 2px;
        }
        .node text {
            font-size: 14px;
        }
        .link {
            fill: none;
            stroke: #999;
            stroke-width: 2px;
        }
        .highlighted-node circle {
            fill: #ff7f0e;
        }
        .highlighted-link {
            stroke: #ff7f0e;
            stroke-width: 3px;
        }
        /* 添加操作锁定时的动画效果 */
        .btn-pulse {
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.5);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(59, 130, 246, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0);
            }
        }
        /* 操作锁定状态的过渡 */
        .operation-status-enter-active, .operation-status-leave-active {
            transition: all 0.3s ease;
        }
        .operation-status-enter-from, .operation-status-leave-to {
            opacity: 0;
            transform: translateY(-10px);
        }
    </style>
</head>
<body class="bg-gray-50">
    <div id="app" v-cloak class="container mx-auto px-4 py-8 max-w-6xl">
        <header class="mb-8">
            <h1 class="text-3xl font-bold text-gray-800 mb-2">数据结构与算法可视化</h1>
            <p class="text-gray-600">支持数组、链表和树结构的可视化演示</p>
        </header>
        
        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <!-- 控制按钮 -->
            <div class="flex flex-wrap gap-4 mb-6">
                <button 
                    @click="startVisualization" 
                    class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                    :disabled="isRunning || isOperationLocked">
                    <i class="fas" :class="isOperationLocked ? 'fa-spinner fa-spin' : 'fa-play'"></i>
                    <span class="ml-2">开始</span>
                </button>
                <button 
                    @click="pauseVisualization" 
                    class="px-4 py-2 bg-yellow-500 text-white rounded hover:bg-yellow-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                    :disabled="!isRunning || isPaused || isOperationLocked">
                    <i class="fas" :class="isOperationLocked ? 'fa-spinner fa-spin' : 'fa-pause'"></i>
                    <span class="ml-2">暂停</span>
                </button>
                <button 
                    @click="stepVisualization" 
                    class="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                    :disabled="(isRunning && !isPaused) || isOperationLocked">
                    <i class="fas" :class="isOperationLocked ? 'fa-spinner fa-spin' : 'fa-step-forward'"></i>
                    <span class="ml-2">下一步</span>
                </button>
                <button 
                    @click="resetVisualization" 
                    class="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                    :disabled="isOperationLocked">
                    <i class="fas" :class="isOperationLocked ? 'fa-spinner fa-spin' : 'fa-redo-alt'"></i>
                    <span class="ml-2">重置</span>
                </button>
            </div>
            
            <!-- 动画速度控制 -->
            <div class="mb-6">
                <label class="block text-sm font-medium text-gray-700 mb-2">动画速度</label>
                <input 
                    type="range" 
                    min="1" 
                    max="10" 
                    v-model="animationSpeed" 
                    class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                <div class="flex justify-between text-xs text-gray-500 mt-1">
                    <span>慢</span>
                    <span>快</span>
                </div>
            </div>
            
            <!-- 进度条 -->
            <div class="mb-8">
                <div class="flex items-center justify-between mb-2">
                    <div class="text-sm font-medium text-gray-700">进度</div>
                    <div class="text-sm text-gray-500">{{ progressText }}</div>
                </div>
                <div class="w-full bg-gray-200 rounded-full h-2.5">
                    <div class="bg-blue-600 h-2.5 rounded-full" :style="{ width: `${progress}%` }"></div>
                </div>
            </div>
            
            <!-- 数据结构选择器 -->
            <div class="flex mb-4 border-b">
                <button 
                    v-for="tab in ['全部', '数组', '链表', '树']" 
                    :key="tab"
                    @click="activeTab = tab"
                    class="px-4 py-2 mr-2 focus:outline-none"
                    :class="activeTab === tab ? 'text-blue-600 border-b-2 border-blue-600 font-medium' : 'text-gray-500 hover:text-gray-700'">
                    {{ tab }}
                </button>
            </div>
            
            <!-- 当前操作信息 -->
            <div class="p-3 bg-blue-50 border border-blue-200 rounded-md text-blue-800 mb-4">
                <div class="flex items-center">
                    <div v-if="isOperationLocked" class="mr-3">
                        <i class="fas fa-spinner fa-spin text-blue-600"></i>
                    </div>
                    <div class="flex-1">
                        <div class="font-medium">{{ isOperationLocked ? '操作进行中...' : '当前操作' }}</div>
                        <div>{{ currentOperation }}</div>
                    </div>
                    <div v-if="isOperationLocked" class="ml-3 text-sm text-blue-600">
                        请等待当前操作完成...
                    </div>
                </div>
            </div>
            
            <!-- 可视化区域 -->
            <div class="grid grid-cols-1 gap-4">
                <!-- 数组可视化 -->
                <div v-if="(activeTab === '全部' || activeTab === '数组') && showArrayContainer" class="visualization-container">
                    <h3 class="text-lg font-semibold mb-2">数组结构</h3>
                    <div id="array-visualization" class="w-full overflow-x-auto pb-4"></div>
                </div>
                
                <!-- 链表可视化 -->
                <div v-if="(activeTab === '全部' || activeTab === '链表') && showLinkedListContainer" class="visualization-container">
                    <h3 class="text-lg font-semibold mb-2">链表结构</h3>
                    <div id="linked-list-visualization" class="w-full overflow-x-auto pb-4"></div>
                </div>
                
                <!-- 树可视化 -->
                <div v-if="(activeTab === '全部' || activeTab === '树') && showTreeContainer" class="visualization-container">
                    <h3 class="text-lg font-semibold mb-2">树结构</h3>
                    <div id="tree-visualization" class="w-full overflow-x-auto pb-4"></div>
                </div>
            </div>
        </div>
        
        <!-- 说明信息 -->
        <div class="bg-white rounded-lg shadow-md p-6">
            <h3 class="text-xl font-semibold text-gray-800 mb-4">多数据结构可视化说明</h3>
            
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                <div>
                    <h4 class="font-semibold text-lg mb-2">数组结构</h4>
                    <p>数组是一种线性数据结构，由一组连续的内存位置组成。</p>
                    <div class="mt-2"><span class="font-semibold">支持操作：</span>创建数组、高亮元素、交换元素、取消高亮</div>
                </div>
                
                <div>
                    <h4 class="font-semibold text-lg mb-2">链表结构</h4>
                    <p>链表是一种线性数据结构，由一系列节点组成，每个节点包含数据和指向下一个节点的引用。</p>
                    <div class="mt-2"><span class="font-semibold">支持操作：</span>创建链表、添加节点、删除节点、插入节点、反转链表等</div>
                </div>
                
                <div>
                    <h4 class="font-semibold text-lg mb-2">树结构</h4>
                    <p>树是一种非线性数据结构，由节点和连接节点的边组成。每个节点可以有多个子节点。</p>
                    <div class="mt-2"><span class="font-semibold">支持操作：</span>创建根节点、添加子节点、删除节点、高亮节点、更新值等</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 引入Font Awesome图标 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/js/all.min.js"></script>
    
    <script>
        const { createApp, ref, computed, onMounted, watch } = Vue;
        
        createApp({
            setup() {
                // 全局控制变量
                const isPaused = ref(true);
                const isRunning = ref(false);
                const currentStep = ref(0);
                const animationSpeed = ref(5);
                const currentOperation = ref('准备就绪');
                const activeTab = ref('全部');
                // 添加操作锁，防止快速重复点击
                const isOperationLocked = ref(false);
                
                // 控制各数据结构容器显示的变量
                const showArrayContainer = ref(false);
                const showLinkedListContainer = ref(false);
                const showTreeContainer = ref(false);
                
                // ==================== 数组相关状态变量 ====================
                const arrayData = ref({});  // 改为对象格式 {arrayId: [数组数据]}
                const arrayHighlighted = ref({}); // 改为对象格式 {arrayId: [高亮索引]}
                const arrayHighlightColors = ref({}); // 改为对象格式 {arrayId: {索引: 颜色}}
                const elementIndices = ref({}); // 改为对象格式 {arrayId: {值: 索引}}
                
                // ==================== 链表相关状态变量 ====================
                const linkedLists = ref({});  // 存储所有链表 {listName: headNode}
                const listNodes = ref({});    // 节点字典，用于快速查找 {nodeId: nodeObject}
                const listNodesData = ref([]); // 节点可视化数据
                const listLinksData = ref([]); // 连线可视化数据
                
                // ==================== 树相关状态变量 ====================
                const trees = ref({});        // 存储所有树 {treeName: rootNode}
                const treeNodes = ref({});    // 节点字典，用于快速查找 {nodeId: nodeObject}
                
                // SVG相关变量
                let arraySvg;
                let arrayGroups;
                const squareSize = 50;
                const gap = 10;
                
                let listSvg;
                let treeSvg;
                
                // 预定义操作队列
                const operationQueue = ref([
                    // 数组操作 - 第一个数组
                    {
            "operation": "create_list",
            "data": {
                "value": 10,
                "id": "node0",
                "clear_visual": true,
                "list_name": "linkedList"
            },
            "metadata": "创建值为10的链表头节点"
        },
        {
            "operation": "append_node",
            "data": {
                "value": 7,
                "id": "node1",
                "list_name": "linkedList"
            },
            "metadata": "在链表尾部添加值为7的新节点"
        }
                ]);
                
                // 计算属性
                const progress = computed(() => {
                    return operationQueue.value.length 
                        ? Math.min(100, Math.round((currentStep.value / operationQueue.value.length) * 100)) 
                        : 0;
                });
                
                const progressText = computed(() => {
                    return `${currentStep.value}/${operationQueue.value.length} 步`;
                });
                
                // 更新元素索引跟踪器
                const updateElementIndices = (arrayId) => {
                    if (!elementIndices.value[arrayId]) {
                        elementIndices.value[arrayId] = {};
                    }
                    
                    const array = arrayData.value[arrayId];
                    if (!array) return;
                    
                    elementIndices.value[arrayId] = {};
                    array.forEach((value, index) => {
                        elementIndices.value[arrayId][value] = index;
                    });
                };
                
                // ==================== D3初始化函数 ====================
                
                // 初始化数组可视化
                const initArrayVisualization = () => {
                    // 清除现有SVG
                    d3.select("#array-visualization").selectAll("*").remove();
                    
                    // 如果没有数组数据，则不创建SVG
                    const arrayCount = Object.keys(arrayData.value).length;
                    if (arrayCount === 0) return;
                    
                    // 计算所需SVG的高度：每个数组需要的高度 + 间距
                    const totalHeight = Math.max(160, Object.keys(arrayData.value).length * 100);
                    
                    // 创建新的SVG容器
                    arraySvg = d3.select("#array-visualization")
                        .append("svg")
                        .attr("width", 1000)
                        .attr("height", totalHeight)
                        .attr("class", "mx-auto");
                };
                
                // 初始化链表可视化
                const initLinkedListVisualization = () => {
                    // 清除现有SVG
                    d3.select("#linked-list-visualization").selectAll("*").remove();
                    
                    // 创建新的SVG容器
                    listSvg = d3.select("#linked-list-visualization")
                        .append("svg")
                        .attr("width", 1000)
                        .attr("height", 300)
                        .append("g")
                        .attr("transform", `translate(50, ${300/2})`);
                        
                    // 定义箭头标记
                    listSvg.append("defs").append("marker")
                        .attr("id", "list-arrowhead")
                        .attr("viewBox", "0 -5 10 10")
                        .attr("refX", 20)
                        .attr("refY", 0)
                        .attr("orient", "auto")
                        .attr("markerWidth", 8)
                        .attr("markerHeight", 8)
                        .append("path")
                        .attr("d", "M0,-5L10,0L0,5")
                        .attr("fill", "#999");
                };
                
                // 初始化树可视化
                const initTreeVisualization = () => {
                    // 清除现有SVG
                    d3.select("#tree-visualization").selectAll("*").remove();
                    
                    // 创建新的SVG容器
                    treeSvg = d3.select("#tree-visualization")
                        .append("svg")
                        .attr("width", 1000)
                        .attr("height", 500)
                        .append("g")
                        .attr("transform", `translate(${1000/4}, 50)`);
                        
                    // 定义箭头标记
                    treeSvg.append("defs").append("marker")
                        .attr("id", "tree-arrowhead")
                        .attr("viewBox", "0 -5 10 10")
                        .attr("refX", 18)
                        .attr("refY", 0)
                        .attr("orient", "auto")
                        .attr("markerWidth", 8)
                        .attr("markerHeight", 8)
                        .append("path")
                        .attr("d", "M0,-5L10,0L0,5")
                        .attr("fill", "#999");
                };
                
                // 通用延迟函数
                const delay = (ms) => {
                    return new Promise(resolve => setTimeout(resolve, ms / animationSpeed.value));
                };
                
                // 创建/更新可视化
                const updateVisualization = () => {
                    // 更新数组可视化
                    initArrayVisualization();
                    
                    // 处理多个数组数据
                    if (Object.keys(arrayData.value).length > 0) {
                        // 创建数组对象的数组，方便处理
                        const arrayEntries = Object.entries(arrayData.value);
                        const arrayGroups = {};
                        
                        // 每个数组占据的垂直空间
                        const verticalOffset = 80;
                        
                        // 为每个数组创建组并绑定数据
                        arrayEntries.forEach(([arrayId, array], arrayIndex) => {
                            // 为该数组创建一个组
                            const groupY = arrayIndex * verticalOffset;
                            
                            // 添加数组标识
                            arraySvg.append("text")
                                .attr("x", 10)
                                .attr("y", groupY + squareSize / 2)
                                .attr("text-anchor", "start")
                                .attr("dominant-baseline", "middle")
                                .attr("font-size", "14px")
                                .attr("font-weight", "bold")
                                .text(arrayId);
                            
                            // 创建数组元素组
                            const group = arraySvg.selectAll(`.array-group-${arrayId}`)
                                .data([arrayId])
                                .enter()
                                .append("g")
                                .attr("class", `array-group-${arrayId}`)
                                .attr("transform", `translate(60, ${groupY})`);
                                
                            // 为数组元素创建子组
                            const elementGroups = group.selectAll(`.array-element-${arrayId}`)
                                .data(array)
                                .enter()
                                .append("g")
                                .attr("class", `array-element-${arrayId}`)
                                .attr("transform", (d, i) => `translate(${i * (squareSize + gap)}, 0)`);
                            
                            // 为每个元素添加方框
                            elementGroups.append("rect")
                                .attr("width", squareSize)
                                .attr("height", squareSize)
                                .attr("fill", (d, i) => {
                                    if (arrayHighlighted.value[arrayId] && arrayHighlighted.value[arrayId].includes(i)) {
                                        return arrayHighlightColors.value[arrayId] && arrayHighlightColors.value[arrayId][i] || "#FF9999";
                                    }
                                    return "white";
                                })
                                .attr("stroke", "#333")
                                .attr("rx", 4);
                            
                            // 为每个元素添加文本
                            elementGroups.append("text")
                                .attr("x", squareSize / 2)
                                .attr("y", squareSize / 2)
                                .attr("text-anchor", "middle")
                                .attr("dominant-baseline", "central")
                                .attr("font-size", "16px")
                                .attr("font-weight", "bold")
                                .text(d => d);
                            
                            // 为每个元素添加索引标签
                            elementGroups.append("text")
                                .attr("x", squareSize / 2)
                                .attr("y", squareSize + 20)
                                .attr("text-anchor", "middle")
                                .attr("dominant-baseline", "central")
                                .attr("font-size", "14px")
                                .attr("fill", "#666")
                                .text((d, i) => i);
                                
                            // 存储引用以便后续更新
                            arrayGroups[arrayId] = {
                                group: group,
                                elementGroups: elementGroups
                            };
                        });
                        
                        // 保存数组组引用
                        window.arrayGroups = arrayGroups;
                    }
                    
                    // 如果需要，更新链表可视化
                    if (Object.keys(linkedLists.value).length > 0) {
                        updateLinkedListVisualization();
                    }
                    
                    // 如果需要，更新树可视化
                    if (Object.keys(trees.value).length > 0) {
                        updateTreeVisualization();
                    }
                };
                
                // ===================== 链表相关函数 =====================
                
                // 更新链表可视化
                const updateLinkedListVisualization = () => {
                    // 初始化链表可视化
                    initLinkedListVisualization();
                    
                    // 生成节点和链接的数据
                    listNodesData.value = [];
                    listLinksData.value = [];
                    
                    // 计算链表数量以确定垂直间距
                    const numLists = Object.keys(linkedLists.value).filter(key => linkedLists.value[key] != null).length;
                    const verticalSpacing = numLists <= 1 ? 0 : 60;
                    
                    // 处理所有链表
                    let listIndex = 0;
                    for (const listName in linkedLists.value) {
                        if (!linkedLists.value[listName]) continue;
                        
                        let xPos = 0;
                        let yPos = listIndex * verticalSpacing;
                        let current = linkedLists.value[listName];
                        
                        while (current) {
                            listNodesData.value.push({
                                id: current.id,
                                value: current.value,
                                x: xPos,
                                y: yPos,
                                listName: listName // 添加链表名称以便于区分
                            });
                            
                            if (current.next) {
                                listLinksData.value.push({
                                    source: {id: current.id, value: current.value},
                                    target: {id: current.next.id, value: current.next.value}
                                });
                            }
                            
                            current = current.next;
                            xPos += 80;
                        }
                        
                        listIndex++;
                    }
                    
                    // 绘制连线
                    const links = listSvg.selectAll(".link")
                        .data(listLinksData.value, d => `${d.source.id}-${d.target.id}`);
                        
                    links.enter()
                        .append("path")
                        .attr("class", "link")
                        .attr("marker-end", "url(#list-arrowhead)")
                        .attr("d", d => {
                            // 计算曲线路径
                            const sourceNode = listNodesData.value.find(node => node.id === d.source.id);
                            const targetNode = listNodesData.value.find(node => node.id === d.target.id);
                            
                            if (sourceNode && targetNode) {
                                return `M${sourceNode.x},${sourceNode.y} L${targetNode.x},${targetNode.y}`;
                            }
                            return "";
                        });
                        
                    // 绘制节点
                    const nodes = listSvg.selectAll(".node")
                        .data(listNodesData.value, d => d.id);
                        
                    const nodeGroups = nodes.enter()
                        .append("g")
                        .attr("class", "node")
                        .attr("transform", d => `translate(${d.x},${d.y})`);
                        
                    // 节点的圆形
                    nodeGroups.append("circle")
                        .attr("r", 12)
                        .on("mouseover", function(event, d) {
                            d3.select(this).transition().duration(300).attr("r", 15);
                        })
                        .on("mouseout", function(event, d) {
                            d3.select(this).transition().duration(300).attr("r", 12);
                        });
                        
                    // 节点的文本
                    nodeGroups.append("text")
                        .attr("dy", ".35em")
                        .attr("text-anchor", "middle")
                        .text(d => d.value);
                    
                    // 确保所有节点都在连线上方
                    listSvg.selectAll(".node").raise();
                };
                
                // 链表操作：创建链表
                const createList = async (operationData) => {
                    initLinkedListVisualization();
                                showLinkedListContainer.value = true;
                                await delay(1000);
                    const listName = operationData.list_name || "linkedList";
                    // 如果要求，初始化可视化
                    if (operationData.clear_visual) {
                        initLinkedListVisualization();
                    }
                    
                    // 创建链表节点
                    const newNode = {
                        id: operationData.id,
                        value: operationData.value,
                        next: null
                    };
                    
                    // 添加到节点字典
                    listNodes.value[operationData.id] = newNode;
                    
                    // 将链表添加到链表字典中
                    linkedLists.value[listName] = newNode;
                    
                    // 更新可视化
                    updateVisualization();
                    
                    // 等待动画完成
                    await delay(1000);
                    // initLinkedListVisualization();
                };
                
                // 链表操作：在链表尾部添加节点
                const appendNode = async (operationData) => {
                    // 显示链表容器
                    // showLinkedListContainer.value = true;
                    
                    const listName = operationData.list_name || "linkedList";
                    
                    // 创建新节点
                    const newNode = {
                        id: operationData.id,
                        value: operationData.value,
                        next: null
                    };
                    
                    // 添加到节点字典
                    listNodes.value[operationData.id] = newNode;
                    
                    // 获取目标链表
                    let currentList = linkedLists.value[listName];
                    
                    // 如果链表为空，则新节点成为头节点
                    if (!currentList) {
                        linkedLists.value[listName] = newNode;
                    } else {
                        // 找到链表的最后一个节点
                        let lastNode = currentList;
                        while (lastNode.next) {
                            lastNode = lastNode.next;
                        }
                        
                        // 将新节点连接到最后一个节点
                        lastNode.next = newNode;
                    }
                    
                    // 更新可视化
                    updateVisualization();
                    
                    // 等待动画完成
                    await delay(1000);
                };
                
                // 链表操作：在指定节点后插入新节点
                const insertAfter = async (operationData) => {
                    // 显示链表容器
                    showLinkedListContainer.value = true;
                    
                    const listName = operationData.list_name || "linkedList";
                    const targetNode = listNodes.value[operationData.target_id];
                    
                    if (!targetNode) {
                        console.error(`目标节点 ${operationData.target_id} 不存在`);
                        currentOperation.value = `错误: 目标节点 ${operationData.target_id} 不存在`;
                        return;
                    }
                    
                    // 创建新节点
                    const newNode = {
                        id: operationData.id,
                        value: operationData.value,
                        next: targetNode.next // 指向目标节点的下一个节点
                    };
                    
                    // 添加到节点字典
                    listNodes.value[operationData.id] = newNode;
                    
                    // 目标节点指向新节点
                    targetNode.next = newNode;
                    
                    // 更新可视化
                    updateVisualization();
                    
                    // 等待动画完成
                    await delay(1000);
                };
                
                // 链表操作：在指定节点前插入新节点
                const insertBefore = async (operationData) => {
                    // 显示链表容器
                    showLinkedListContainer.value = true;
                    
                    const listName = operationData.list_name || "linkedList";
                    const targetNode = listNodes.value[operationData.target_id];
                    
                    if (!targetNode) {
                        console.error(`目标节点 ${operationData.target_id} 不存在`);
                        currentOperation.value = `错误: 目标节点 ${operationData.target_id} 不存在`;
                        return;
                    }
                    
                    // 创建新节点
                    const newNode = {
                        id: operationData.id,
                        value: operationData.value,
                        next: targetNode // 指向目标节点
                    };
                    
                    // 添加到节点字典
                    listNodes.value[operationData.id] = newNode;
                    
                    // 查找目标节点所在的链表
                    let foundList = null;
                    for (const listKey in linkedLists.value) {
                        if (isNodeInList(targetNode.id, linkedLists.value[listKey])) {
                            foundList = listKey;
                            break;
                        }
                    }
                    
                    if (!foundList) {
                        console.error(`未找到包含目标节点 ${operationData.target_id} 的链表`);
                        currentOperation.value = `错误: 未找到包含目标节点 ${operationData.target_id} 的链表`;
                        return;
                    }
                    
                    // 找到指向目标节点的节点
                    let prevNode = null;
                    let current = linkedLists.value[foundList];
                    
                    while (current && current.id !== targetNode.id) {
                        prevNode = current;
                        current = current.next;
                    }
                    
                    if (prevNode) {
                        // 将前一个节点指向新节点
                        prevNode.next = newNode;
                    } else {
                        // 如果目标节点是头节点，则新节点成为头节点
                        linkedLists.value[foundList] = newNode;
                    }
                    
                    // 更新可视化
                    updateVisualization();
                    
                    // 等待动画完成
                    await delay(1000);
                };
                
                // 辅助函数：检查节点是否在指定链表中
                function isNodeInList(nodeId, list) {
                    let current = list;
                    while (current) {
                        if (current.id === nodeId) {
                            return true;
                        }
                        current = current.next;
                    }
                    return false;
                }
                
                // 链表操作：高亮节点
                const highlightNode = async (operationData) => {
                    // 显示链表容器
                    showLinkedListContainer.value = true;
                    
                    listSvg.selectAll(".node")
                        .filter(d => d.id === operationData.id)
                        .classed("highlighted-node", true)
                        .select("circle")
                        .transition()
                        .duration(500)
                        .attr("r", 15);
                    
                    // 等待动画完成
                    await delay(500);
                };
                
                // 链表操作：取消高亮节点
                const unhighlightNode = async (operationData) => {
                    // 显示链表容器
                    showLinkedListContainer.value = true;
                    
                    listSvg.selectAll(".node")
                        .filter(d => d.id === operationData.id)
                        .classed("highlighted-node", false)
                        .select("circle")
                        .transition()
                        .duration(500)
                        .attr("r", 12);
                    
                    // 等待动画完成
                    await delay(500);
                };
                
                // 链表操作：删除节点
                const removeNode = async (operationData) => {
                    // 显示链表容器
                    showLinkedListContainer.value = true;
                    
                    const listName = operationData.list_name || "linkedList";
                    const nodeId = operationData.id;
                    const nodeToRemove = listNodes.value[nodeId];
                    
                    if (!nodeToRemove) {
                        console.error(`节点 ${nodeId} 不存在`);
                        currentOperation.value = `错误: 节点 ${nodeId} 不存在`;
                        return;
                    }
                    
                    // 查找目标节点所在的链表
                    let foundList = null;
                    for (const listKey in linkedLists.value) {
                        if (isNodeInList(nodeId, linkedLists.value[listKey])) {
                            foundList = listKey;
                            break;
                        }
                    }
                    
                    if (!foundList) {
                        console.error(`未找到包含节点 ${nodeId} 的链表`);
                        currentOperation.value = `错误: 未找到包含节点 ${nodeId} 的链表`;
                        return;
                    }
                    
                    // 找到指向目标节点的节点
                    let prevNode = null;
                    let current = linkedLists.value[foundList];
                    
                    while (current && current.id !== nodeId) {
                        prevNode = current;
                        current = current.next;
                    }
                    
                    if (prevNode) {
                        // 将前一个节点指向目标节点的下一个节点
                        prevNode.next = nodeToRemove.next;
                    } else {
                        // 如果目标节点是头节点，则将头节点指向下一个节点
                        linkedLists.value[foundList] = nodeToRemove.next;
                    }
                    
                    // 从节点字典中删除目标节点
                    delete listNodes.value[nodeId];
                    
                    // 更新可视化
                    updateVisualization();
                    
                    // 等待动画完成
                    await delay(1000);
                };
                
                // 链表操作：在链表头部添加节点
                const prependNode = async (operationData) => {
                    // 显示链表容器
                    showLinkedListContainer.value = true;
                    
                    const listName = operationData.list_name || "linkedList";
                    
                    // 获取目标链表
                    const currentList = linkedLists.value[listName];
                    
                    // 创建新节点
                    const newNode = {
                        id: operationData.id,
                        value: operationData.value,
                        next: currentList // 指向当前的头节点
                    };
                    
                    // 添加到节点字典
                    listNodes.value[operationData.id] = newNode;
                    
                    // 新节点成为头节点
                    linkedLists.value[listName] = newNode;
                    
                    // 更新可视化
                    updateVisualization();
                    
                    // 等待动画完成
                    await delay(1000);
                };
                
                // 操作函数：合并两个链表
                const mergeLists = async (operationData) => {
                    // 显示链表容器
                    showLinkedListContainer.value = true;
                    
                    const list1Name = operationData.list1_name;
                    const list2Name = operationData.list2_name;
                    const newListName = operationData.new_list_id || "merged";
                    
                    // 获取链表头节点
                    const list1Head = linkedLists.value[list1Name];
                    const list2Head = linkedLists.value[list2Name];
                    
                    if (!list1Head || !list2Head) {
                        console.error(`链表 ${list1Name} 或 ${list2Name} 不存在`);
                        currentOperation.value = `错误: 链表 ${list1Name} 或 ${list2Name} 不存在`;
                        return;
                    }
                    
                    // 高亮两个链表中的所有节点
                    const nodeIds = [];
                    let current = list1Head;
                    while (current) {
                        nodeIds.push(current.id);
                        current = current.next;
                    }
                    current = list2Head;
                    while (current) {
                        nodeIds.push(current.id);
                        current = current.next;
                    }
                    
                    // 高亮所有相关节点
                    for (const nodeId of nodeIds) {
                        listSvg.selectAll(".node")
                            .filter(d => d.id === nodeId)
                            .classed("highlighted-node", true)
                            .select("circle")
                            .transition()
                            .duration(500)
                            .attr("r", 15);
                    }
                    
                    await delay(500);
                    
                    // 找到第一个链表的尾节点
                    current = list1Head;
                    while (current.next) {
                        current = current.next;
                    }
                    
                    // 将第二个链表连接到第一个链表的尾部
                    current.next = list2Head;
                    
                    // 创建合并后的新链表
                    linkedLists.value[newListName] = list1Head;
                    
                    // 删除原始链表（无条件执行）
                    delete linkedLists.value[list1Name];
                    delete linkedLists.value[list2Name];
                    
                    // 更新可视化
                    updateVisualization();
                    
                    // 取消高亮
                    for (const nodeId of nodeIds) {
                        listSvg.selectAll(".node")
                            .filter(d => d.id === nodeId)
                            .classed("highlighted-node", false)
                            .select("circle")
                            .transition()
                            .duration(500)
                            .attr("r", 12);
                    }
                    
                    // 等待动画完成
                    await delay(500);
                };
                
                // 操作函数：拆分链表
                const splitList = async (operationData) => {
                    // 显示链表容器
                    showLinkedListContainer.value = true;
                    
                    const listName = operationData.list_name;
                    const splitAfterId = operationData.split_after_id;
                    const newListId = operationData.new_list_id || "splitList";
                    
                    // 获取链表头节点
                    let head = linkedLists.value[listName];
                    
                    if (!head) {
                        console.error(`链表 ${listName} 为空或不存在`);
                        currentOperation.value = `错误: 链表 ${listName} 为空或不存在`;
                        return;
                    }
                    
                    // 找到分割点
                    const splitNode = listNodes.value[splitAfterId];
                    if (!splitNode) {
                        console.error(`分割节点 ${splitAfterId} 不存在`);
                        currentOperation.value = `错误: 分割节点 ${splitAfterId} 不存在`;
                        return;
                    }
                    
                    // 检查节点是否在指定链表中
                    if (!isNodeInList(splitAfterId, head)) {
                        console.error(`在链表 ${listName} 中未找到分割节点 ${splitAfterId}`);
                        currentOperation.value = `错误: 在链表 ${listName} 中未找到分割节点 ${splitAfterId}`;
                        return;
                    }
                    
                    // 找到分割点
                    let current = head;
                    while (current && current.id !== splitAfterId) {
                        current = current.next;
                    }
                    
                    // 确保我们找到了分割点
                    if (!current) {
                        console.error(`未能找到分割节点 ${splitAfterId}`);
                        currentOperation.value = `错误: 未能找到分割节点 ${splitAfterId}`;
                        return;
                    }
                    
                    // 高亮分割点
                    listSvg.selectAll(".node")
                        .filter(d => d.id === splitAfterId)
                        .classed("highlighted-node", true)
                        .select("circle")
                        .transition()
                        .duration(500)
                        .attr("r", 15);
                    
                    await delay(500);
                    
                    // 第二个链表从分割点的下一个节点开始
                    const secondHead = current.next;
                    // 切断第一个链表与第二个链表的连接
                    current.next = null;
                    
                    // 创建新链表
                    linkedLists.value[newListId] = secondHead;
                    
                    // 取消高亮
                    listSvg.selectAll(".node")
                        .filter(d => d.id === splitAfterId)
                        .classed("highlighted-node", false)
                        .select("circle")
                        .transition()
                        .duration(500)
                        .attr("r", 12);
                    
                    // 更新可视化
                    updateVisualization();
                    
                    // 等待动画完成
                    await delay(1000);
                };
                
                // 操作函数：高亮链接
                const highlightLink = async (operationData) => {
                    // 显示链表容器
                    showLinkedListContainer.value = true;
                    
                    // 获取源节点和目标节点
                    const sourceId = operationData.source_id;
                    const targetId = operationData.target_id;
                    
                    // 高亮连线
                    listSvg.selectAll(".link")
                        .filter(d => d.source.id === sourceId && d.target.id === targetId)
                        .classed("highlighted-link", true)
                        .transition()
                        .duration(500);
                    
                    // 等待动画完成
                    await delay(500);
                };
                
                // 操作函数：取消高亮链接
                const unhighlightLink = async (operationData) => {
                    // 显示链表容器
                    showLinkedListContainer.value = true;
                    
                    // 获取源节点和目标节点
                    const sourceId = operationData.source_id;
                    const targetId = operationData.target_id;
                    
                    // 取消高亮连线
                    listSvg.selectAll(".link")
                        .filter(d => d.source.id === sourceId && d.target.id === targetId)
                        .classed("highlighted-link", false)
                        .transition()
                        .duration(500);
                    
                    // 等待动画完成
                    await delay(500);
                };
                
                // 操作函数：更新节点值
                const updateValue = async (operationData) => {
                    // 显示链表容器
                    showLinkedListContainer.value = true;
                    
                    const nodeId = operationData.id;
                    const newValue = operationData.value;
                    
                    // 获取节点
                    const node = listNodes.value[nodeId];
                    if (!node) {
                        console.error(`节点 ${nodeId} 不存在`);
                        currentOperation.value = `错误: 节点 ${nodeId} 不存在`;
                        return;
                    }
                    
                    // 高亮节点以表示正在更新
                    listSvg.selectAll(".node")
                        .filter(d => d.id === nodeId)
                        .classed("highlighted-node", true)
                        .select("circle")
                        .transition()
                        .duration(500)
                        .attr("r", 15);
                    
                    await delay(500);
                    
                    // 更新节点值
                    node.value = newValue;
                    
                    // 更新文本
                    listSvg.selectAll(".node")
                        .filter(d => d.id === nodeId)
                        .select("text")
                        .text(newValue);
                    
                    // 取消高亮
                    listSvg.selectAll(".node")
                        .filter(d => d.id === nodeId)
                        .classed("highlighted-node", false)
                        .select("circle")
                        .transition()
                        .duration(500)
                        .attr("r", 12);
                    
                    // 更新可视化
                    updateVisualization();
                    
                    // 等待动画完成
                    await delay(500);
                };
                
                // 操作函数：反转链表
                const reverseList = async (operationData) => {
                    // 显示链表容器
                    showLinkedListContainer.value = true;
                    
                    const listName = operationData.list_name || "linkedList";
                    
                    // 获取链表头节点
                    let head = linkedLists.value[listName];
                    
                    if (!head) {
                        console.error(`链表 ${listName} 为空或不存在`);
                        currentOperation.value = `错误: 链表 ${listName} 为空或不存在`;
                        return;
                    }
                    
                    // 高亮整个链表，表示将要反转
                    const nodeIds = [];
                    let current = head;
                    while (current) {
                        nodeIds.push(current.id);
                        current = current.next;
                    }
                    
                    // 高亮所有节点
                    for (const nodeId of nodeIds) {
                        listSvg.selectAll(".node")
                            .filter(d => d.id === nodeId)
                            .classed("highlighted-node", true)
                            .select("circle")
                            .transition()
                            .duration(500)
                            .attr("r", 15);
                    }
                    
                    await delay(500);
                    
                    // 反转链表
                    let prev = null;
                    current = head;
                    
                    while (current) {
                        const next = current.next;
                        current.next = prev;
                        prev = current;
                        current = next;
                    }
                    
                    // 更新头节点
                    linkedLists.value[listName] = prev;
                    
                    // 更新可视化
                    updateVisualization();
                    
                    // 取消高亮
                    for (const nodeId of nodeIds) {
                        listSvg.selectAll(".node")
                            .filter(d => d.id === nodeId)
                            .classed("highlighted-node", false)
                            .select("circle")
                            .transition()
                            .duration(500)
                            .attr("r", 12);
                    }
                    
                    // 等待动画完成
                    await delay(500);
                };
                
                // 操作函数：交换节点值
                const swapNodes = async (operationData) => {
                    // 显示链表容器
                    showLinkedListContainer.value = true;
                    
                    const id1 = operationData.id1;
                    const id2 = operationData.id2;
                    
                    // 获取节点
                    const node1 = listNodes.value[id1];
                    const node2 = listNodes.value[id2];
                    
                    if (!node1 || !node2) {
                        console.error(`节点 ${id1} 或 ${id2} 不存在`);
                        currentOperation.value = `错误: 节点 ${id1} 或 ${id2} 不存在`;
                        return;
                    }
                    
                    // 高亮要交换的节点
                    listSvg.selectAll(".node")
                        .filter(d => d.id === id1 || d.id === id2)
                        .classed("highlighted-node", true)
                        .select("circle")
                        .transition()
                        .duration(500)
                        .attr("r", 15);
                    
                    await delay(500);
                    
                    // 交换节点值
                    const tempValue = node1.value;
                    node1.value = node2.value;
                    node2.value = tempValue;
                    
                    // 更新文本
                    listSvg.selectAll(".node")
                        .filter(d => d.id === id1)
                        .select("text")
                        .text(node1.value);
                    
                    listSvg.selectAll(".node")
                        .filter(d => d.id === id2)
                        .select("text")
                        .text(node2.value);
                    
                    // 取消高亮
                    listSvg.selectAll(".node")
                        .filter(d => d.id === id1 || d.id === id2)
                        .classed("highlighted-node", false)
                        .select("circle")
                        .transition()
                        .duration(500)
                        .attr("r", 12);
                    
                    // 更新可视化
                    updateVisualization();
                    
                    // 等待动画完成
                    await delay(1000);
                };
                
                // 执行单步操作
                const executeStep = async () => {
                    // 如果操作被锁定，则不执行
                    if (isOperationLocked.value) return false;
                    
                    // 如果已经执行完所有步骤，则退出
                    if (currentStep.value >= operationQueue.value.length) {
                        currentOperation.value = "可视化完成";
                        isRunning.value = false;
                        return false;
                    }
                    
                    try {
                        // 锁定操作
                        isOperationLocked.value = true;
                        
                        const operation = operationQueue.value[currentStep.value];
                        currentOperation.value = operation.metadata || "执行操作";
                        
                        switch (operation.operation) {
                            // 数组操作
                            case "create_array":
                                await createArray(operation.data);
                                break;
                            case "swap_elements":
                                await swapElements(operation.data);
                                break;
                            case "highlight":
                                await highlight(operation.data);
                                break;
                            case "unhighlight":
                                await unhighlight(operation.data);
                                break;
                                
                            // 链表操作
                            case "create_list":
                                
                                await createList(operation.data);
                                break;
                            case "append_node":
                                await appendNode(operation.data);
                                break;
                            case "prepend_node":
                                await prependNode(operation.data);
                                break;
                            case "insert_after":
                                await insertAfter(operation.data);
                                break;
                            case "insert_before":
                                await insertBefore(operation.data);
                                break;
                            case "remove_node":
                                await removeNode(operation.data);
                                break;
                            case "highlight_node":
                                await highlightNode(operation.data);
                                break;
                            case "unhighlight_node":
                                await unhighlightNode(operation.data);
                                break;
                            
                            case "merge_lists":
                                await mergeLists(operation.data);
                                break;
                            case "split_list":
                                await splitList(operation.data);
                                break;
                            case "highlight_link":
                                await highlightLink(operation.data);
                                break;
                            case "unhighlight_link":
                                await unhighlightLink(operation.data);
                                break;
                            case "update_value":
                                await updateValue(operation.data);
                                break;
                            case "reverse_list":
                                await reverseList(operation.data);
                                break;
                            case "swap_nodes":
                                await swapNodes(operation.data);
                                break;
                                
                            default:
                                console.warn(`未知操作: ${operation.operation}`);
                        }
                        
                        // 增加步骤计数
                        currentStep.value++;
                        
                        // 解锁操作
                        isOperationLocked.value = false;
                        return true;
                    } catch (error) {
                        console.error(`执行操作 ${operation.operation} 时出错:`, error);
                        currentOperation.value = `操作 ${operation.operation} 执行失败: ${error.message}`;
                        // 发生错误时也要解锁
                        isOperationLocked.value = false;
                        return false;
                    }
                };
                
                // 执行队列
                const executeQueue = async () => {
                    while (!isPaused.value && isRunning.value && currentStep.value < operationQueue.value.length) {
                        const success = await executeStep();
                        if (!success) break;
                        
                        // 在每一步之间添加小延迟，避免界面卡顿
                        await delay(300);
                    }
                };
                
                // 添加简单的防抖函数
                const debounce = (fn, ms = 300) => {
                    let timeoutId;
                    return function(...args) {
                        clearTimeout(timeoutId);
                        timeoutId = setTimeout(() => fn.apply(this, args), ms);
                    };
                };
                
                // 控制函数
                const startVisualization = () => {
                    // 如果操作被锁定，不执行
                    if (isOperationLocked.value) return;
                    
                    isRunning.value = true;
                    isPaused.value = false;
                    executeQueue();
                };
                
                const pauseVisualization = () => {
                    isPaused.value = true;
                };
                
                const stepVisualization = async () => {
                    // 如果操作被锁定，不执行
                    if (isOperationLocked.value) return;
                    
                    if (!isRunning.value) {
                        isRunning.value = true;
                    }
                    isPaused.value = true;
                    await executeStep();
                };
                
                const resetVisualization = () => {
                    // 如果操作被锁定，不执行
                    if (isOperationLocked.value) return;
                    
                    isPaused.value = true;
                    isRunning.value = false;
                    currentStep.value = 0;
                    currentOperation.value = "准备就绪";
                
                    arrayHighlighted.value = {};
                    arrayHighlightColors.value = {};
                
                    arrayData.value = {};
                    elementIndices.value = {};
                    
                    // 重置链表和树
                    linkedLists.value = {};
                    listNodes.value = {};
                    trees.value = {};
                    treeNodes.value = {};
                    
                    // 重置容器显示状态
                    showArrayContainer.value = false;
                    showLinkedListContainer.value = false;
                    showTreeContainer.value = false;
                    
                    // 重置全局引用
                    if (window.arrayGroups) {
                        delete window.arrayGroups;
                    }
                    
                    // 更新可视化
                    updateVisualization();
                };
                
                // 组件挂载后初始化
                onMounted(() => {
                    // 初始化数组为空对象
                    arrayData.value = {};
                    arrayHighlighted.value = {};
                    arrayHighlightColors.value = {};
                    elementIndices.value = {};
                    
                    // 确保所有容器初始都不显示
                    showArrayContainer.value = false;
                    showLinkedListContainer.value = false;
                    showTreeContainer.value = false;
                    
                    // 初始化可视化
                    updateVisualization();
                });
                
                return {
                    isPaused,
                    isRunning,
                    currentStep,
                    animationSpeed,
                    currentOperation,
                    progress,
                    progressText,
                    startVisualization,
                    pauseVisualization,
                    stepVisualization,
                    resetVisualization,
                    arrayData,
                    arrayHighlighted,
                    activeTab,
                    isOperationLocked, // 导出锁状态
                    
                    // 容器显示状态
                    showArrayContainer,
                    showLinkedListContainer,
                    showTreeContainer,
                    
                    // 列出所有需要在模板中使用的变量
                    linkedLists,
                    trees
                };
            }
        }).mount("#app");
    </script>
</body>
</html>
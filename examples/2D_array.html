<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>二维数组算法可视化</title>
    <!-- 引入Vue.js -->
    <script src="https://cdn.jsdelivr.net/npm/vue@3.2.47/dist/vue.global.js"></script>
    <!-- 引入D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- 引入Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        [v-cloak] { 
            display: none; 
        }
        .fade-enter-active, .fade-leave-active {
            transition: opacity 0.5s;
        }
        .fade-enter-from, .fade-leave-to {
            opacity: 0;
        }
        .grid-cell {
            transition: all 0.3s ease;
        }
    </style>
</head>
<body class="bg-gray-50">
    <div id="app" v-cloak class="container mx-auto px-4 py-8 max-w-6xl">
        <header class="mb-8">
            <h1 class="text-3xl font-bold text-gray-800 mb-2">二维数组算法可视化</h1>
            <p class="text-gray-600">使用现代Web技术实现的二维数组算法可视化工具</p>
        </header>
        
        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <div class="flex flex-wrap gap-4 mb-6">
                <button 
                    @click="startVisualization" 
                    class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                    :disabled="isRunning">
                    <i class="fas fa-play mr-2"></i>开始
                </button>
                <button 
                    @click="pauseVisualization" 
                    class="px-4 py-2 bg-yellow-500 text-white rounded hover:bg-yellow-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                    :disabled="!isRunning || isPaused">
                    <i class="fas fa-pause mr-2"></i>暂停
                </button>
                <button 
                    @click="stepVisualization" 
                    class="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                    :disabled="isRunning && !isPaused">
                    <i class="fas fa-step-forward mr-2"></i>下一步
                </button>
                <button 
                    @click="resetVisualization" 
                    class="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition-colors">
                    <i class="fas fa-redo-alt mr-2"></i>重置
                </button>
            </div>
            
            <div class="mb-6">
                <label class="block text-sm font-medium text-gray-700 mb-2">动画速度</label>
                <input 
                    type="range" 
                    min="1" 
                    max="10" 
                    v-model="animationSpeed" 
                    class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                <div class="flex justify-between text-xs text-gray-500 mt-1">
                    <span>慢</span>
                    <span>快</span>
                </div>
            </div>
            
            <div class="mb-8">
                <div class="flex items-center justify-between mb-2">
                    <div class="text-sm font-medium text-gray-700">进度</div>
                    <div class="text-sm text-gray-500">{{ progressText }}</div>
                </div>
                <div class="w-full bg-gray-200 rounded-full h-2.5">
                    <div class="bg-blue-600 h-2.5 rounded-full" :style="{ width: `${progress}%` }"></div>
                </div>
            </div>
            
            <!-- 二维数组可视化区域 -->
            <div class="mt-6 text-lg font-semibold text-gray-700">可视化显示：</div>
            <div id="visualization" class="w-full overflow-x-auto pb-4 mt-2"></div>
            
            <div class="mt-4 p-3 bg-blue-50 border border-blue-200 rounded-md text-blue-800 min-h-[60px]">
                {{ currentOperation }}
            </div>

            <!-- 显示当前数组状态 -->
            <div class="mt-4 bg-gray-100 p-3 rounded">
                <div class="font-semibold mb-2">当前数组状态:</div>
                <div v-if="matrices && currentMatrixId">
                    <div v-for="(row, rowIdx) in matrices[currentMatrixId]" :key="rowIdx" class="flex">
                        <div v-for="(cell, colIdx) in row" :key="colIdx"
                            class="w-12 h-12 flex items-center justify-center border border-gray-300 m-1"
                            :class="{
                                'bg-red-200': isHighlighted(rowIdx, colIdx),
                                'bg-orange-200': isRowHighlighted(rowIdx),
                                'bg-blue-200': isColumnHighlighted(colIdx),
                                'font-bold': isHighlighted(rowIdx, colIdx) || isRowHighlighted(rowIdx) || isColumnHighlighted(colIdx)
                            }">
                            {{ cell }}
                        </div>
                    </div>
                </div>
                <div v-else class="text-gray-600">暂无数据</div>
            </div>
        </div>
        
        <div class="bg-white rounded-lg shadow-md p-6">
            <h3 class="text-xl font-semibold text-gray-800 mb-4">可视化操作说明</h3>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                    <p class="mb-4">本工具展示了二维数组操作的可视化实现，支持多种数组操作。</p>
                    <div class="mb-2"><span class="font-semibold">支持基础操作：</span></div>
                    <ul class="list-disc pl-5 space-y-1 text-sm">
                        <li>创建二维数组</li>
                        <li>高亮/取消高亮元素</li>
                        <li>高亮/取消高亮行或列</li>
                        <li>交换元素、行或列</li>
                        <li>更新元素值</li>
                    </ul>
                </div>
                <div>
                    <div class="mb-2"><span class="font-semibold">支持高级操作：</span></div>
                    <ul class="list-disc pl-5 space-y-1 text-sm">
                        <li>添加/删除行或列</li>
                        <li>调整数组大小</li>
                        <li>提取子数组</li>
                        <li>矩阵转置</li>
                    </ul>
                    <div class="mt-4 mb-2"><span class="font-semibold">控制方式：</span>使用上方的按钮控制可视化的执行</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 引入Font Awesome图标 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/js/all.min.js"></script>
    
    <script>
        const { createApp, ref, computed, onMounted, watch } = Vue;
        
        createApp({
            setup() {
                // 状态变量
                const isPaused = ref(true);
                const isRunning = ref(false);
                const currentStep = ref(0);
                const animationSpeed = ref(5);
                const currentOperation = ref('准备就绪');
                
                // 二维数组相关状态
                const matrices = ref({}); // 存储所有矩阵，使用ID作为键
                const currentMatrixId = ref(''); // 当前显示的矩阵ID
                
                // 高亮状态跟踪
                const highlightedCells = ref([]); // [{row, col}]格式
                const highlightedRows = ref([]); // [row1, row2, ...]格式
                const highlightedColumns = ref([]); // [col1, col2, ...]格式
                
                // 辅助函数：检查单元格是否被高亮
                const isHighlighted = (row, col) => {
                    return highlightedCells.value.some(cell => cell.row === row && cell.col === col);
                };
                
                // 检查行是否被高亮
                const isRowHighlighted = (row) => {
                    return highlightedRows.value.includes(row);
                };
                
                // 检查列是否被高亮
                const isColumnHighlighted = (col) => {
                    return highlightedColumns.value.includes(col);
                };
                
                // 示例操作队列
                const operationQueue = ref([
                    {
                        "operation": "create_2d_array",
                        "data": {
                            "array": [
                                [1, 2, 3],
                                [4, 5, 6],
                                [7, 8, 9]
                            ],
                            "id": "arr2d_1"
                        },
                        "metadata": "创建一个3x3的二维数组"
                    },
                    {
                        "operation": "highlight_element",
                        "data": {
                            "position": {"row": 0, "col": 2},
                            "id": "arr2d_1"
                        },
                        "metadata": "高亮位置(0,2)的元素"
                    },
                    {
                        "operation": "highlight_elements",
                        "data": {
                            "positions": [
                                {"row": 0, "col": 0},
                                {"row": 0, "col": 1}
                            ],
                            "id": "arr2d_1"
                        },
                        "metadata": "高亮多个元素"
                    },
                    {
                        "operation": "unhighlight_element",
                        "data": {
                            "position": {"row": 0, "col": 2},
                            "id": "arr2d_1"
                        },
                        "metadata": "取消高亮位置(0,2)的元素"
                    },
                    {
                        "operation": "swap_elements",
                        "data": {
                            "position1": {"row": 0, "col": 0},
                            "position2": {"row": 1, "col": 1},
                            "id": "arr2d_1"
                        },
                        "metadata": "交换位置(0,0)和(1,1)的元素"
                    },
                    {
                        "operation": "unhighlight_elements",
                        "data": {
                            "positions": [
                                {"row": 0, "col": 0},
                                {"row": 0, "col": 1}
                            ],
                            "id": "arr2d_1"
                        },
                        "metadata": "取消高亮多个元素"
                    },
                    {
                        "operation": "highlight_row",
                        "data": {
                            "row": 1,
                            "id": "arr2d_1"
                        },
                        "metadata": "高亮第1行(从0开始计数)"
                    },
                    {
                        "operation": "highlight_column",
                        "data": {
                            "col": 2,
                            "id": "arr2d_1"
                        },
                        "metadata": "高亮第2列(从0开始计数)"
                    },
                    {
                        "operation": "unhighlight_row",
                        "data": {
                            "row": 1,
                            "id": "arr2d_1"
                        },
                        "metadata": "取消高亮第1行"
                    },
                    {
                        "operation": "unhighlight_column",
                        "data": {
                            "col": 2,
                            "id": "arr2d_1"
                        },
                        "metadata": "取消高亮第2列"
                    },
                    {
                        "operation": "update_element",
                        "data": {
                            "position": {"row": 2, "col": 2},
                            "value": 100,
                            "id": "arr2d_1"
                        },
                        "metadata": "更新位置(2,2)的元素值为100"
                    },
                    {
                        "operation": "swap_rows",
                        "data": {
                            "row1": 0,
                            "row2": 2,
                            "id": "arr2d_1"
                        },
                        "metadata": "交换第0行和第2行"
                    },
                    {
                        "operation": "swap_columns",
                        "data": {
                            "col1": 0,
                            "col2": 2,
                            "id": "arr2d_1"
                        },
                        "metadata": "交换第0列和第2列"
                    },
                    {
                        "operation": "transpose",
                        "data": {
                            "id": "arr2d_1"
                        },
                        "metadata": "矩阵转置"
                    },
                    {
                        "operation": "add_row",
                        "data": {
                            "row": [10, 11, 12],
                            "position": 1,
                            "id": "arr2d_1"
                        },
                        "metadata": "在位置1插入新行"
                    },
                    {
                        "operation": "add_column",
                        "data": {
                            "column": [10, 11, 12, 13],
                            "position": 1,
                            "id": "arr2d_1"
                        },
                        "metadata": "在位置1插入新列"
                    },
                    {
                        "operation": "remove_row",
                        "data": {
                            "row": 1,
                            "id": "arr2d_1"
                        },
                        "metadata": "删除第1行"
                    },
                    {
                        "operation": "remove_column",
                        "data": {
                            "col": 1,
                            "id": "arr2d_1"
                        },
                        "metadata": "删除第1列"
                    },
                    {
                        "operation": "resize",
                        "data": {
                            "rows": 4,
                            "cols": 5,
                            "default_value": 0,
                            "id": "arr2d_1"
                        },
                        "metadata": "将数组调整为4行5列，新增位置用0填充"
                    },
                    {
                        "operation": "subarray",
                        "data": {
                            "start_row": 0,
                            "start_col": 0,
                            "end_row": 1,
                            "end_col": 1,
                            "id": "arr2d_1",
                            "new_id": "arr2d_sub"
                        },
                        "metadata": "提取子数组并赋予新ID"
                    }
                ]);
                
                // 计算属性
                const progress = computed(() => {
                    return operationQueue.value.length 
                        ? Math.min(100, Math.round((currentStep.value / operationQueue.value.length) * 100)) 
                        : 0;
                });
                
                const progressText = computed(() => {
                    return `${currentStep.value}/${operationQueue.value.length} 步`;
                });
                
                // SVG相关变量
                let svg;
                const cellSize = 60;
                const spacing = 5;
                let currentMatrix = null;
                
                // 深拷贝函数
                const deepCopy = (obj) => {
                    return JSON.parse(JSON.stringify(obj));
                };
                
                // 初始化D3
                const initD3 = () => {
                    // 清除现有SVG
                    d3.select("#visualization").selectAll("*").remove();
                    
                    if (!currentMatrixId.value || !matrices.value[currentMatrixId.value]) return;
                    
                    currentMatrix = matrices.value[currentMatrixId.value];
                    const rows = currentMatrix.length;
                    const cols = rows > 0 ? currentMatrix[0].length : 0;
                    
                    // 创建SVG容器
                    svg = d3.select("#visualization")
                        .append("svg")
                        .attr("width", cols * (cellSize + spacing) + spacing)
                        .attr("height", rows * (cellSize + spacing) + spacing + 30) // 额外空间用于显示列索引
                        .attr("class", "mx-auto");
                    
                    // 添加列索引标签
                    for (let j = 0; j < cols; j++) {
                        svg.append("text")
                            .attr("x", spacing + j * (cellSize + spacing) + cellSize / 2)
                            .attr("y", 20)
                            .attr("text-anchor", "middle")
                            .attr("font-size", "14px")
                            .attr("fill", "#666")
                            .text(`列${j}`);
                    }
                    
                    // 创建行组
                    const rows_g = svg.selectAll(".row")
                        .data(currentMatrix)
                        .enter()
                        .append("g")
                        .attr("class", "row")
                        .attr("transform", (d, i) => `translate(0, ${i * (cellSize + spacing) + spacing + 30})`);
                    
                    // 添加行索引标签
                    rows_g.append("text")
                        .attr("x", 0)
                        .attr("y", cellSize / 2)
                        .attr("text-anchor", "end")
                        .attr("dominant-baseline", "middle")
                        .attr("font-size", "14px")
                        .attr("fill", "#666")
                        .text((d, i) => `行${i}`);
                    
                    // 为每行添加单元格
                    rows_g.selectAll(".cell")
                        .data((d, i) => d.map((value, j) => ({ value, row: i, col: j })))
                        .enter()
                        .append("g")
                        .attr("class", "cell")
                        .attr("transform", (d, i) => `translate(${spacing + i * (cellSize + spacing)}, 0)`)
                        .append("rect")
                        .attr("width", cellSize)
                        .attr("height", cellSize)
                        .attr("fill", (d) => {
                            if (isHighlighted(d.row, d.col)) return "#FF9999";
                            if (isRowHighlighted(d.row)) return "#FFCC99";
                            if (isColumnHighlighted(d.col)) return "#99CCFF";
                            return "white";
                        })
                        .attr("stroke", "#333")
                        .attr("rx", 4);
                    
                    // 为单元格添加文本
                    rows_g.selectAll(".cell")
                        .append("text")
                        .attr("x", cellSize / 2)
                        .attr("y", cellSize / 2)
                        .attr("text-anchor", "middle")
                        .attr("dominant-baseline", "central")
                        .attr("font-size", "16px")
                        .attr("font-weight", (d) => {
                            if (isHighlighted(d.row, d.col) || 
                                isRowHighlighted(d.row) || 
                                isColumnHighlighted(d.col)) return "bold";
                            return "normal";
                        })
                        .text(d => d.value);
                };
                
                // 延迟函数
                const delay = (ms = 500) => {
                    return new Promise(resolve => setTimeout(resolve, ms));
                };
                
                // 操作函数：创建二维数组
                const create2DArray = async (operationData) => {
                    const { array, id } = operationData;
                    matrices.value[id] = deepCopy(array);
                    currentMatrixId.value = id;
                    
                    // 清除所有高亮状态
                    highlightedCells.value = [];
                    highlightedRows.value = [];
                    highlightedColumns.value = [];
                    
                    // 更新可视化
                    initD3();
                    
                    await delay();
                };
                
                // 操作函数：高亮单元格
                const highlightElement = async (operationData) => {
                    const { position, id } = operationData;
                    
                    if (currentMatrixId.value !== id) {
                        currentMatrixId.value = id;
                    }
                    
                    // 添加到高亮列表
                    highlightedCells.value.push({ row: position.row, col: position.col });
                    
                    // 更新可视化
                    initD3();
                    
                    await delay(500 / animationSpeed.value);
                };
                
                // 操作函数：高亮多个单元格
                const highlightElements = async (operationData) => {
                    const { positions, id } = operationData;
                    
                    if (currentMatrixId.value !== id) {
                        currentMatrixId.value = id;
                    }
                    
                    // 添加所有位置到高亮列表
                    positions.forEach(pos => {
                        highlightedCells.value.push({ row: pos.row, col: pos.col });
                    });
                    
                    // 更新可视化
                    initD3();
                    
                    await delay(500 / animationSpeed.value);
                };
                
                // 操作函数：取消高亮单元格
                const unhighlightElement = async (operationData) => {
                    const { position, id } = operationData;
                    
                    if (currentMatrixId.value !== id) {
                        currentMatrixId.value = id;
                    }
                    
                    // 从高亮列表中移除
                    highlightedCells.value = highlightedCells.value.filter(
                        cell => !(cell.row === position.row && cell.col === position.col)
                    );
                    
                    // 更新可视化
                    initD3();
                    
                    await delay(500 / animationSpeed.value);
                };
                
                // 操作函数：取消高亮多个单元格
                const unhighlightElements = async (operationData) => {
                    const { positions, id } = operationData;
                    
                    if (currentMatrixId.value !== id) {
                        currentMatrixId.value = id;
                    }
                    
                    // 从高亮列表中移除所有指定位置
                    positions.forEach(pos => {
                        highlightedCells.value = highlightedCells.value.filter(
                            cell => !(cell.row === pos.row && cell.col === pos.col)
                        );
                    });
                    
                    // 更新可视化
                    initD3();
                    
                    await delay(500 / animationSpeed.value);
                };
                
                // 操作函数：高亮行
                const highlightRow = async (operationData) => {
                    const { row, id } = operationData;
                    
                    if (currentMatrixId.value !== id) {
                        currentMatrixId.value = id;
                    }
                    
                    // 添加到高亮行列表
                    if (!highlightedRows.value.includes(row)) {
                        highlightedRows.value.push(row);
                    }
                    
                    // 更新可视化
                    initD3();
                    
                    await delay(500 / animationSpeed.value);
                };
                
                // 操作函数：取消高亮行
                const unhighlightRow = async (operationData) => {
                    const { row, id } = operationData;
                    
                    if (currentMatrixId.value !== id) {
                        currentMatrixId.value = id;
                    }
                    
                    // 从高亮行列表中移除
                    highlightedRows.value = highlightedRows.value.filter(r => r !== row);
                    
                    // 更新可视化
                    initD3();
                    
                    await delay(500 / animationSpeed.value);
                };
                
                // 操作函数：高亮列
                const highlightColumn = async (operationData) => {
                    const { col, id } = operationData;
                    
                    if (currentMatrixId.value !== id) {
                        currentMatrixId.value = id;
                    }
                    
                    // 添加到高亮列列表
                    if (!highlightedColumns.value.includes(col)) {
                        highlightedColumns.value.push(col);
                    }
                    
                    // 更新可视化
                    initD3();
                    
                    await delay(500 / animationSpeed.value);
                };
                
                // 操作函数：取消高亮列
                const unhighlightColumn = async (operationData) => {
                    const { col, id } = operationData;
                    
                    if (currentMatrixId.value !== id) {
                        currentMatrixId.value = id;
                    }
                    
                    // 从高亮列列表中移除
                    highlightedColumns.value = highlightedColumns.value.filter(c => c !== col);
                    
                    // 更新可视化
                    initD3();
                    
                    await delay(500 / animationSpeed.value);
                };
                
                // 操作函数：交换元素
                const swapElements = async (operationData) => {
                    const { position1, position2, id } = operationData;
                    
                    if (currentMatrixId.value !== id) {
                        currentMatrixId.value = id;
                    }
                    
                    const matrix = matrices.value[id];
                    
                    // 保存要交换的值
                    const temp = matrix[position1.row][position1.col];
                    matrix[position1.row][position1.col] = matrix[position2.row][position2.col];
                    matrix[position2.row][position2.col] = temp;
                    
                    // 使用D3动画显示交换过程
                    if (svg) {
                        // 创建临时标记高亮两个正在交换的元素
                        const tempHighlighted = [...highlightedCells.value];
                        highlightedCells.value = [
                            { row: position1.row, col: position1.col },
                            { row: position2.row, col: position2.col }
                        ];
                        
                        // 更新可视化以显示高亮
                        initD3();
                        
                        // 延迟后恢复原始高亮状态
                        await delay(800 / animationSpeed.value);
                        
                        highlightedCells.value = tempHighlighted;
                    }
                    
                    // 更新可视化
                    initD3();
                    
                    await delay(200 / animationSpeed.value);
                };
                
                // 操作函数：更新元素
                const updateElement = async (operationData) => {
                    const { position, value, id } = operationData;
                    
                    if (currentMatrixId.value !== id) {
                        currentMatrixId.value = id;
                    }
                    
                    const matrix = matrices.value[id];
                    
                    // 更新值
                    matrix[position.row][position.col] = value;
                    
                    // 临时高亮显示更新的元素
                    const tempHighlighted = [...highlightedCells.value];
                    highlightedCells.value = [{ row: position.row, col: position.col }];
                    
                    // 更新可视化
                    initD3();
                    
                    // 延迟后恢复原始高亮状态
                    await delay(800 / animationSpeed.value);
                    
                    highlightedCells.value = tempHighlighted;
                    
                    // 更新可视化
                    initD3();
                    
                    await delay(200 / animationSpeed.value);
                };
                
                // 操作函数：交换行
                // 操作函数：交换行
const swapRows = async (operationData) => {
    const { row1, row2, id } = operationData;
    
    if (currentMatrixId.value !== id) {
        currentMatrixId.value = id;
    }
    
    const matrix = matrices.value[id];
    
    // 临时高亮两行
    const tempHighlightedRows = [...highlightedRows.value];
    highlightedRows.value = [row1, row2];
    
    // 更新可视化以显示高亮
    initD3();
    
    await delay(500 / animationSpeed.value);
    
    // 交换行
    const tempRow = matrix[row1];
    matrix[row1] = matrix[row2];
    matrix[row2] = tempRow;
    
    // 更新可视化
    initD3();
    
    // 恢复原始高亮状态
    await delay(500 / animationSpeed.value);
    highlightedRows.value = tempHighlightedRows;
    
    // 最终更新可视化
    initD3();
    
    await delay(200 / animationSpeed.value);
};

// 操作函数：交换列
const swapColumns = async (operationData) => {
    const { col1, col2, id } = operationData;
    
    if (currentMatrixId.value !== id) {
        currentMatrixId.value = id;
    }
    
    const matrix = matrices.value[id];
    
    // 临时高亮两列
    const tempHighlightedColumns = [...highlightedColumns.value];
    highlightedColumns.value = [col1, col2];
    
    // 更新可视化以显示高亮
    initD3();
    
    await delay(500 / animationSpeed.value);
    
    // 交换列
    for (let i = 0; i < matrix.length; i++) {
        const temp = matrix[i][col1];
        matrix[i][col1] = matrix[i][col2];
        matrix[i][col2] = temp;
    }
    
    // 更新可视化
    initD3();
    
    // 恢复原始高亮状态
    await delay(500 / animationSpeed.value);
    highlightedColumns.value = tempHighlightedColumns;
    
    // 最终更新可视化
    initD3();
    
    await delay(200 / animationSpeed.value);
};

// 操作函数：矩阵转置
const transpose = async (operationData) => {
    const { id } = operationData;
    
    if (currentMatrixId.value !== id) {
        currentMatrixId.value = id;
    }
    
    const matrix = matrices.value[id];
    const rows = matrix.length;
    const cols = rows > 0 ? matrix[0].length : 0;
    
    // 创建新矩阵进行转置
    const transposed = Array(cols).fill().map(() => Array(rows).fill(0));
    
    // 执行转置操作，同时添加动画效果
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            // 突出显示当前处理的单元格
            highlightedCells.value = [{ row: i, col: j }];
            initD3();
            await delay(50 / animationSpeed.value);
            
            // 执行转置
            transposed[j][i] = matrix[i][j];
        }
    }
    
    // 更新矩阵
    matrices.value[id] = transposed;
    
    // 清除高亮
    highlightedCells.value = [];
    
    // 更新可视化
    initD3();
    
    await delay(500 / animationSpeed.value);
};

// 操作函数：添加行
const addRow = async (operationData) => {
    const { row, position, id } = operationData;
    
    if (currentMatrixId.value !== id) {
        currentMatrixId.value = id;
    }
    
    const matrix = matrices.value[id];
    
    // 在指定位置插入新行
    matrix.splice(position, 0, [...row]);
    
    // 临时高亮新添加的行
    const tempHighlightedRows = [...highlightedRows.value];
    highlightedRows.value = [position];
    
    // 更新可视化
    initD3();
    
    // 延迟后恢复原始高亮状态
    await delay(800 / animationSpeed.value);
    
    highlightedRows.value = tempHighlightedRows;
    
    // 更新可视化
    initD3();
    
    await delay(200 / animationSpeed.value);
};

// 操作函数：添加列
const addColumn = async (operationData) => {
    const { column, position, id } = operationData;
    
    if (currentMatrixId.value !== id) {
        currentMatrixId.value = id;
    }
    
    const matrix = matrices.value[id];
    
    // 在每行的指定位置插入新值
    for (let i = 0; i < matrix.length; i++) {
        if (i < column.length) {
            matrix[i].splice(position, 0, column[i]);
        } else {
            // 如果column数组长度不足，使用默认值0
            matrix[i].splice(position, 0, 0);
        }
    }
    
    // 临时高亮新添加的列
    const tempHighlightedColumns = [...highlightedColumns.value];
    highlightedColumns.value = [position];
    
    // 更新可视化
    initD3();
    
    // 延迟后恢复原始高亮状态
    await delay(800 / animationSpeed.value);
    
    highlightedColumns.value = tempHighlightedColumns;
    
    // 更新可视化
    initD3();
    
    await delay(200 / animationSpeed.value);
};

// 操作函数：删除行
const removeRow = async (operationData) => {
    const { row, id } = operationData;
    
    if (currentMatrixId.value !== id) {
        currentMatrixId.value = id;
    }
    
    const matrix = matrices.value[id];
    
    // 高亮将要删除的行
    highlightedRows.value = [row];
    
    // 更新可视化
    initD3();
    
    await delay(500 / animationSpeed.value);
    
    // 删除行
    matrix.splice(row, 1);
    
    // 清除高亮状态
    highlightedRows.value = [];
    
    // 更新可视化
    initD3();
    
    await delay(500 / animationSpeed.value);
};

// 操作函数：删除列
const removeColumn = async (operationData) => {
    const { col, id } = operationData;
    
    if (currentMatrixId.value !== id) {
        currentMatrixId.value = id;
    }
    
    const matrix = matrices.value[id];
    
    // 高亮将要删除的列
    highlightedColumns.value = [col];
    
    // 更新可视化
    initD3();
    
    await delay(500 / animationSpeed.value);
    
    // 从每行中删除指定列
    for (let i = 0; i < matrix.length; i++) {
        matrix[i].splice(col, 1);
    }
    
    // 清除高亮状态
    highlightedColumns.value = [];
    
    // 更新可视化
    initD3();
    
    await delay(500 / animationSpeed.value);
};

// 操作函数：调整数组大小
const resize = async (operationData) => {
    const { rows, cols, default_value, id } = operationData;
    
    if (currentMatrixId.value !== id) {
        currentMatrixId.value = id;
    }
    
    const matrix = matrices.value[id];
    const oldRows = matrix.length;
    const oldCols = oldRows > 0 ? matrix[0].length : 0;
    
    // 调整行数
    if (rows > oldRows) {
        // 添加新行
        for (let i = oldRows; i < rows; i++) {
            const newRow = Array(oldCols).fill(default_value);
            matrix.push(newRow);
            
            // 高亮新添加的行
            highlightedRows.value = [i];
            initD3();
            await delay(300 / animationSpeed.value);
        }
    } else if (rows < oldRows) {
        // 删除多余的行
        for (let i = oldRows - 1; i >= rows; i--) {
            // 高亮将要删除的行
            highlightedRows.value = [i];
            initD3();
            await delay(300 / animationSpeed.value);
            
            matrix.pop();
        }
    }
    
    // 调整列数
    for (let i = 0; i < matrix.length; i++) {
        if (cols > oldCols) {
            // 添加新列
            for (let j = oldCols; j < cols; j++) {
                matrix[i].push(default_value);
                
                // 动画效果，高亮新添加的单元格
                if (i === 0) {
                    highlightedColumns.value = [j];
                    initD3();
                    await delay(200 / animationSpeed.value);
                }
            }
        } else if (cols < oldCols) {
            // 删除多余的列
            if (i === 0) {
                for (let j = oldCols - 1; j >= cols; j--) {
                    // 高亮将要删除的列
                    highlightedColumns.value = [j];
                    initD3();
                    await delay(200 / animationSpeed.value);
                }
            }
            
            // 调整列数
            matrix[i].length = cols;
        }
    }
    
    // 清除高亮状态
    highlightedRows.value = [];
    highlightedColumns.value = [];
    
    // 更新可视化
    initD3();
    
    await delay(500 / animationSpeed.value);
};

// 操作函数：提取子数组
const subarray = async (operationData) => {
    const { start_row, start_col, end_row, end_col, id, new_id } = operationData;
    
    if (currentMatrixId.value !== id) {
        currentMatrixId.value = id;
    }
    
    const matrix = matrices.value[id];
    
    // 高亮要提取的区域
    const highlightPositions = [];
    for (let i = start_row; i <= end_row; i++) {
        for (let j = start_col; j <= end_col; j++) {
            highlightPositions.push({ row: i, col: j });
        }
    }
    
    // 保存原始高亮状态
    const tempHighlightedCells = [...highlightedCells.value];
    
    // 设置新的高亮状态
    highlightedCells.value = highlightPositions;
    
    // 更新可视化
    initD3();
    
    await delay(800 / animationSpeed.value);
    
    // 创建子数组
    const sub = [];
    for (let i = start_row; i <= end_row; i++) {
        const row = [];
        for (let j = start_col; j <= end_col; j++) {
            row.push(matrix[i][j]);
        }
        sub.push(row);
    }
    
    // 保存子数组
    matrices.value[new_id] = sub;
    
    // 切换到子数组
    currentMatrixId.value = new_id;
    
    // 恢复原始高亮状态
    highlightedCells.value = [];
    
    // 更新可视化
    initD3();
    
    await delay(500 / animationSpeed.value);
};

// 主函数：执行单步操作
const executeOperation = async (operation) => {
    currentOperation.value = operation.metadata || '执行操作...';
    
    switch (operation.operation) {
        case "create_2d_array":
            await create2DArray(operation.data);
            break;
        case "highlight_element":
            await highlightElement(operation.data);
            break;
        case "highlight_elements":
            await highlightElements(operation.data);
            break;
        case "unhighlight_element":
            await unhighlightElement(operation.data);
            break;
        case "unhighlight_elements":
            await unhighlightElements(operation.data);
            break;
        case "swap_elements":
            await swapElements(operation.data);
            break;
        case "update_element":
            await updateElement(operation.data);
            break;
        case "highlight_row":
            await highlightRow(operation.data);
            break;
        case "unhighlight_row":
            await unhighlightRow(operation.data);
            break;
        case "highlight_column":
            await highlightColumn(operation.data);
            break;
        case "unhighlight_column":
            await unhighlightColumn(operation.data);
            break;
        case "swap_rows":
            await swapRows(operation.data);
            break;
        case "swap_columns":
            await swapColumns(operation.data);
            break;
        case "transpose":
            await transpose(operation.data);
            break;
        case "add_row":
            await addRow(operation.data);
            break;
        case "add_column":
            await addColumn(operation.data);
            break;
        case "remove_row":
            await removeRow(operation.data);
            break;
        case "remove_column":
            await removeColumn(operation.data);
            break;
        case "resize":
            await resize(operation.data);
            break;
        case "subarray":
            await subarray(operation.data);
            break;
        default:
            console.log("未知操作:", operation.operation);
            await delay(500 / animationSpeed.value);
    }
};

// 开始可视化
const startVisualization = async () => {
    if (isRunning.value) return;
    isRunning.value = true;
    isPaused.value = false;
    
    while (currentStep.value < operationQueue.value.length && isRunning.value && !isPaused.value) {
        await executeOperation(operationQueue.value[currentStep.value]);
        currentStep.value++;
    }
    
    if (currentStep.value >= operationQueue.value.length) {
        isRunning.value = false;
        currentOperation.value = '所有操作已完成!';
    }
};

// 暂停可视化
const pauseVisualization = () => {
    isPaused.value = true;
    currentOperation.value = '可视化已暂停，点击"开始"继续或"下一步"单步执行';
};

// 单步执行
const stepVisualization = async () => {
    if (currentStep.value < operationQueue.value.length) {
        if (!isRunning.value) {
            isRunning.value = true;
            isPaused.value = true;
        }
        
        await executeOperation(operationQueue.value[currentStep.value]);
        currentStep.value++;
        
        if (currentStep.value >= operationQueue.value.length) {
            isRunning.value = false;
            currentOperation.value = '所有操作已完成!';
        }
    }
};

// 重置可视化
const resetVisualization = () => {
    isRunning.value = false;
    isPaused.value = true;
    currentStep.value = 0;
    matrices.value = {};
    currentMatrixId.value = '';
    highlightedCells.value = [];
    highlightedRows.value = [];
    highlightedColumns.value = [];
    currentOperation.value = '准备就绪';
    
    // 清除可视化
    d3.select("#visualization").selectAll("*").remove();
};

// 添加3D数组操作支持
// 操作函数：创建3D数组
const create3DArray = async (operationData) => {
    const { array, id } = operationData;
    matrices.value[id] = deepCopy(array);
    currentMatrixId.value = id;
    currentDimension.value = 3;
    
    // 清除所有高亮状态
    highlightedCells.value = [];
    highlightedRows.value = [];
    highlightedColumns.value = [];
    highlightedLayers.value = [];
    
    // 更新可视化
    initD3For3D();
    
    await delay();
};

// 初始化3D数组显示
const initD3For3D = () => {
    // 清除现有SVG
    d3.select("#visualization").selectAll("*").remove();
    
    if (!currentMatrixId.value || !matrices.value[currentMatrixId.value]) return;
    
    const array3D = matrices.value[currentMatrixId.value];
    const layers = array3D.length;
    
    // 创建选择器，允许用户选择查看的层
    const selectorDiv = d3.select("#visualization")
        .append("div")
        .attr("class", "flex items-center gap-4 mb-4");
    
    selectorDiv.append("label")
        .attr("class", "text-sm font-medium text-gray-700")
        .text("选择查看的层:");
    
    const selector = selectorDiv.append("select")
        .attr("class", "form-select rounded border-gray-300 shadow-sm")
        .on("change", function() {
            currentLayer.value = +this.value;
            updateLayerView();
        });
    
    for (let i = 0; i < layers; i++) {
        selector.append("option")
            .attr("value", i)
            .text(`层 ${i}`);
    }
    
    // 添加容器用于显示当前层
    d3.select("#visualization")
        .append("div")
        .attr("id", "layer-view")
        .attr("class", "mt-4");
    
    // 初始化显示第一层
    currentLayer.value = 0;
    updateLayerView();
};

// 更新当前查看的层
const updateLayerView = () => {
    const layerView = d3.select("#layer-view");
    layerView.selectAll("*").remove();
    
    const array3D = matrices.value[currentMatrixId.value];
    const currentMatrix = array3D[currentLayer.value];
    const rows = currentMatrix.length;
    const cols = rows > 0 ? currentMatrix[0].length : 0;
    
    // 创建SVG容器
    const svg = layerView.append("svg")
        .attr("width", cols * (cellSize + spacing) + spacing)
        .attr("height", rows * (cellSize + spacing) + spacing + 30)
        .attr("class", "mx-auto");
    
    // 显示当前层信息
    svg.append("text")
        .attr("x", 10)
        .attr("y", 20)
        .attr("font-size", "14px")
        .attr("font-weight", "bold")
        .attr("fill", "#333")
        .text(`当前显示: 层 ${currentLayer.value}`);
    
    // 添加列索引标签
    for (let j = 0; j < cols; j++) {
        svg.append("text")
            .attr("x", spacing + j * (cellSize + spacing) + cellSize / 2)
            .attr("y", 20)
            .attr("text-anchor", "middle")
            .attr("font-size", "14px")
            .attr("fill", "#666")
            .text(`列${j}`);
    }
    
    // 创建行组
    const rows_g = svg.selectAll(".row")
        .data(currentMatrix)
        .enter()
        .append("g")
        .attr("class", "row")
        .attr("transform", (d, i) => `translate(0, ${i * (cellSize + spacing) + spacing + 30})`);
    
    // 添加行索引标签
    rows_g.append("text")
        .attr("x", 0)
        .attr("y", cellSize / 2)
        .attr("text-anchor", "end")
        .attr("dominant-baseline", "middle")
        .attr("font-size", "14px")
        .attr("fill", "#666")
        .text((d, i) => `行${i}`);
    
    // 为每行添加单元格
    rows_g.selectAll(".cell")
        .data((d, i) => d.map((value, j) => ({ value, row: i, col: j })))
        .enter()
        .append("g")
        .attr("class", "cell")
        .attr("transform", (d, i) => `translate(${spacing + i * (cellSize + spacing)}, 0)`)
        .append("rect")
        .attr("width", cellSize)
        .attr("height", cellSize)
        .attr("fill", (d) => {
            if (isHighlighted3D(currentLayer.value, d.row, d.col)) return "#FF9999";
            if (isRowHighlighted(d.row)) return "#FFCC99";
            if (isColumnHighlighted(d.col)) return "#99CCFF";
            if (isLayerHighlighted(currentLayer.value)) return "#D1CBE8";
            return "white";
        })
        .attr("stroke", "#333")
        .attr("rx", 4);
    
    // 为单元格添加文本
    rows_g.selectAll(".cell")
        .append("text")
        .attr("x", cellSize / 2)
        .attr("y", cellSize / 2)
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "central")
        .attr("font-size", "16px")
        .attr("font-weight", (d) => {
            if (isHighlighted3D(currentLayer.value, d.row, d.col) || 
                isRowHighlighted(d.row) || 
                isColumnHighlighted(d.col) ||
                isLayerHighlighted(currentLayer.value)) return "bold";
            return "normal";
        })
        .text(d => d.value);
};

// 添加3D数组相关状态
const currentDimension = ref(2); // 2D或3D
const currentLayer = ref(0); // 当前查看的3D数组层
const highlightedLayers = ref([]); // 高亮的层

// 3D数组元素高亮检查
const isHighlighted3D = (layer, row, col) => {
    return highlightedCells.value.some(cell => 
        cell.layer === layer && cell.row === row && cell.col === col);
};

// 检查层是否被高亮
const isLayerHighlighted = (layer) => {
    return highlightedLayers.value.includes(layer);
};

// 操作函数：高亮3D数组元素
const highlight3DElement = async (operationData) => {
    const { position, id } = operationData;
    
    if (currentMatrixId.value !== id) {
        currentMatrixId.value = id;
    }
    
    // 添加到高亮列表
    highlightedCells.value.push({ 
        layer: position.layer, 
        row: position.row, 
        col: position.col 
    });
    
    // 确保当前显示正确的层
    if (currentLayer.value !== position.layer) {
        currentLayer.value = position.layer;
    }
    
    // 更新可视化
    updateLayerView();
    
    await delay(500 / animationSpeed.value);
};

// 操作函数：高亮层
const highlightLayer = async (operationData) => {
    const { layer, id } = operationData;
    
    if (currentMatrixId.value !== id) {
        currentMatrixId.value = id;
    }
    
    // 添加到高亮层列表
    if (!highlightedLayers.value.includes(layer)) {
        highlightedLayers.value.push(layer);
    }
    
    // 确保当前显示正确的层
    if (currentLayer.value !== layer) {
        currentLayer.value = layer;
    }
    
    // 更新可视化
    updateLayerView();
    
    await delay(500 / animationSpeed.value);
};

// 操作函数：取消高亮层
const unhighlightLayer = async (operationData) => {
    const { layer, id } = operationData;
    
    if (currentMatrixId.value !== id) {
        currentMatrixId.value = id;
    }
    
    // 从高亮层列表中移除
    highlightedLayers.value = highlightedLayers.value.filter(l => l !== layer);
    
    // 更新可视化
    updateLayerView();
    
    await delay(500 / animationSpeed.value);
};

// 将新的3D操作添加到executeOperation函数中
const originalExecuteOperation = executeOperation;
const executeOperation = async (operation) => {
    currentOperation.value = operation.metadata || '执行操作...';
    
    switch (operation.operation) {
        case "create_3d_array":
            await create3DArray(operation.data);
            break;
        case "highlight_3d_element":
            await highlight3DElement(operation.data);
            break;
        case "highlight_layer":
            await highlightLayer(operation.data);
            break;
        case "unhighlight_layer":
            await unhighlightLayer(operation.data);
            break;
        default:
            // 调用原始函数处理2D操作
            await originalExecuteOperation(operation);
    }
};

// 组件挂载时初始化
onMounted(() => {
    // 初始状态设置
    resetVisualization();
});

// 暴露接口
return {
    isPaused,
    isRunning,
    currentStep,
    animationSpeed,
    currentOperation,
    matrices,
    currentMatrixId,
    highlightedCells,
    highlightedRows,
    highlightedColumns,
    highlightedLayers,
    currentDimension,
    currentLayer,
    operationQueue,
    progress,
    progressText,
    isHighlighted,
    isRowHighlighted,
    isColumnHighlighted,
    isLayerHighlighted,
    startVisualization,
    pauseVisualization,
    stepVisualization,
    resetVisualization
};
}}).mount('#app');
</script>
</body>
</html>